package types

import (
	"bytes"
	"crypto/rand"
	"encoding"
	"fmt"

	"github.com/direct-connect/go-dc/tiger"
)

const base32Enc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"

// SIDFromInt converts a 20 bit integer to a SID.
func SIDFromInt(v uint32) (id SID) {
	for i := len(id) - 1; i >= 0; i-- {
		id[i] = base32Enc[v%32]
		v /= 32
	}
	return
}

// SIDFromString parses a 4-byte base32 encoded SID value. It panics on error.
func SIDFromString(s string) (id SID) {
	if err := id.UnmarshalADC([]byte(s)); err != nil {
		panic(err)
	}
	return
}

// SID (Session ID) appears in all communication that interacts with the hub.
// They identify a unique user on a single hub and are assigned by the hub during initial protocol negotiation.
// SIDs are 20 bits long and encoded using a 4-byte base32 encoded string.
type SID [4]byte

func (id SID) String() string {
	return string(id[:])
}

// MarshalADC implements adc.Marshaler.
func (id SID) MarshalADC(buf *bytes.Buffer) error {
	buf.Write(id[:])
	return nil
}

// UnmarshalADC implements adc.Unmarshaler.
func (id *SID) UnmarshalADC(s []byte) error {
	if len(s) != 4 {
		return fmt.Errorf("wrong SID format: %q", s)
	}
	var buf [4]byte
	copy(buf[:], s)
	*id = SID(buf)
	return nil
}

// MustParseCID parses a base32 CID string and panics on error.
func MustParseCID(s string) (out CID) {
	if err := out.FromBase32(s); err != nil {
		panic(err)
	}
	return
}

// MustParseCIDP is the same as MustParseCID, but returns a pointer to a new value.
func MustParseCIDP(s string) *CID {
	out := MustParseCID(s)
	return &out
}

var (
	_ encoding.TextMarshaler   = CID{}
	_ encoding.TextUnmarshaler = (*CID)(nil)
)

var zeroCID = CID{}

// CID (Client ID) globally and publicly identify a unique client and underlie client to client communication.
//
// They are generated by hashing the (unencoded) PID with the session hash algorithm.
//
// Hubs should register clients by CID. CID length follows the length of the hash algorithm used for the session.
// Clients must be prepared to handle CIDs of varying lengths.
type CID [tiger.Size]byte

// IsZero check if CID value is zero.
func (id CID) IsZero() bool {
	return id == zeroCID
}

// String returns base32 representation of the CID.
func (id CID) String() string {
	return id.Base32()
}

// MarshalText implements encoding.TextMarshaler.
func (id CID) MarshalText() ([]byte, error) {
	return []byte(id.Base32()), nil
}

// UnmarshalText implements encoding.TextUnmarshaler.
func (id *CID) UnmarshalText(text []byte) error {
	return id.FromBase32(string(text))
}

// MarshalADC implements adc.Marshaler.
func (id CID) MarshalADC(buf *bytes.Buffer) error {
	buf.WriteString(id.Base32())
	return nil
}

// UnmarshalADC implements adc.Unmarshaler.
func (id *CID) UnmarshalADC(s []byte) error {
	return id.FromBase32(string(s))
}

// Base32 returns base32 representation of the CID.
func (id CID) Base32() string {
	return tiger.Hash(id).Base32()
}

// FromBase32 parses CID from base32 encoding.
func (id *CID) FromBase32(s string) error {
	var th tiger.Hash
	if err := th.FromBase32(s); err != nil {
		return err
	}
	*id = CID(th)
	return nil
}

// Hash returns a Tiger hash of the CID.
func (id CID) Hash() CID {
	return (CID)(tiger.HashBytes(id[:]))
}

// PID (Private ID) globally identify a unique client.
//
// They function during initial protocol negotiation to generate the CID and are invisible to other clients.
// PIDs should be generated in a way to avoid collisions, for example using the hash of the current time and primary
// network card MAC address if sufficient randomness cannot be generated.
//
// Hubs and clients may not disclose PIDs to other clients; doing so weakens the security of the ADC network.
// Clients should should keep the same PID between sessions and hubs. PID length follows the length of the hash
// algorithm used for the session.
type PID = CID

// NewPID generates a new Private ID using a cryptographic random source.
func NewPID() (id PID, err error) {
	_, err = rand.Reader.Read(id[:])
	return
}
